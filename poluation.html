<!DOCTYPE html>
<html>

<head>
    <title>Chinese Economics</title>
    <link rel="stylesheet" href="style.css" />
    <link rel="shortcut icon" type="image/x-icon" href="resources/favicon.ico" />
    <script src="scripts/d3.min.js"></script>
    <script src="scripts/d3-geo-projection.min.js"></script>
</head>

<body>
    <p style='font-size: 20pt; text-align: center;'>China Global Trade Visualization</p>
    <svg width="800" height="400" id="world-race-svg" class="svgs" style='display: block;'></svg>
    <svg width="1000" height="600" id="world-map-svg" class="svgs" style='display: block; margin: 0 auto;'></svg>
    <script>
        const width = 1200;
        const height = 600;
        const minValue = 56095;
        const maxValue = 1337705000;

        const barSvg = d3.select('#world-race-svg');
        const worldMapSvg = d3.select('#world-map-svg');


        let geo, geoData, boundaries, monthData;
        const dataLoadandSetup = async function () {
            geo = await d3.json('data/worldmap/geoData.geojson');
            //console.log(geo.features);
            geoData = geo.features;
            console.log(geo.features);
            boundaries = await d3.json('data/worldmap/boundaries.json');
            monthData = await d3.csv('data/worldmap/global-by-month.csv');
            console.log(monthData);
        }

        async function renderBarRacing(data) {
            const xValue = d => parseFloat(d.number);
            const yValue = d => d.country;
            const xScale = d3.scaleLinear();
            const yScale = d3.scaleBand();
            const sp = d3.scalePoint();
            const colorScale = d3.scaleOrdinal();
            const formatFloat = d3.format(".2f");

            let xAxis = d3.axisBottom(xScale);
            let yAxis = d3.axisLeft(yScale);

            const margin = { top: 60, right: 60, bottom: 60, left: 100 };
            const width = barSvg.attr('width');
            const height = barSvg.attr('height');
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;
            const mainGroup = barSvg.append('g')
                .attr('transform', `translate(${margin.left}, ${margin.top})`);
            const container = mainGroup.append('g').classed("container", true);
            //const innerWidth = barSvg.attr('width') - 100;
            //const innerHeight = barSvg.attr('height') - 100;
            //console.log(innerWidth, innerHeight);

            //const container = barSvg.append('g').classed('container', true);
            const dateLabel = barSvg.append('text')
                .attr('x', innerWidth - 50)
                .attr('y', innerHeight - 50)
                .attr('class', 'year-label')
                .text('0000');

            const xAxisGroup = mainGroup.append('g')
                .attr('transform', `translate(${0}, ${innerHeight})`);
            const yAxisGroup = mainGroup.append('g');

            xAxisGroup.append('text')
                .attr('font-size', '15pt')
                .attr('font-weight', 'bold')
                .attr('text-anchor', 'middle')
                .attr('x', innerWidth / 2)
                .attr('y', 50)
                .attr('fill', '#000000')
                .text('Global Import');

            yAxisGroup.append('text')
                .attr('font-size', '15pt')
                .attr('font-weight', 'bold')
                .attr('transform', `rotate(-90)`)
                .attr('text-anchor', 'middle')
                .attr('x', -innerHeight / 2)
                .attr('y', -50)
                .attr('fill', '#000000');

            const interval = 1500;

            sp.domain(data.map(d => d.country)).range([0, 1]);
            data = data.filter((country) => country.dir == 'Import')
            data = d3.group(data, d => d.time);
            const dateList = Array.from(data.keys()).sort((a, b) => a - b);
            console.log(data);
            console.log("datelist", dateList);

            const updateBarChart = (date) => {
                const transition = d3.transition().duration(interval).ease(d3.easeLinear);
                dateLabel.text(dateList[date]);
                monthData = data.get(dateList[date]);
                monthData = [...monthData].sort((a, b) => b.number - a.number).slice(0, 20);
                yScale.domain(monthData.map(yValue)).range([0, innerHeight]).padding(0.1);
                xScale.domain([0, d3.max(monthData, xValue)]).range([0, innerWidth]);

                container.selectAll('rect').data(monthData, d => d.country).enter().append('rect')
                    .style("fill", d => d3.interpolateSpectral(sp(yValue(d))))
                    .attr('width', 0)
                    .attr('x', 0)
                    .attr('y', d => yScale(yValue(d)))
                    .attr('height', yScale.bandwidth());

                container.selectAll('rect').data(monthData, d => d.country).join('rect')
                    .transition(transition)
                    .attr('width', d => xScale(xValue(d)))
                    .attr('y', d => yScale(yValue(d)))
                    .attr('height', yScale.bandwidth());

                container.selectAll("text").data(monthData, d => d.country).enter().append('text')
                    .attr("x", 0)
                    .attr("y", d => yScale(yValue(d)) + yScale.bandwidth() / 2)
                    .attr("text-anchor", "start")
                    .attr("dx", "0.1em")
                    .attr("dy", "5")
                    .attr("class", "value-label")

                container.selectAll("text").data(monthData, d => d.country).join('text')
                    .transition(transition)
                    .attr("x", d => xScale(xValue(d)))
                    .attr("y", d => yScale(yValue(d)) + yScale.bandwidth() / 2)
                    .attr("text-anchor", "start")
                    .attr("dx", "0.1em")
                    .attr("dy", "5")
                    .attr("class", "value-label")
                    //.attr('text', d => d.country);
                    .tween("text", function (d) {
                        var i = d3.interpolate(this.textContent, d.number);
                        return function (t) {
                            this.textContent = formatFloat(i(t));
                        }
                    });

                //adding axes:
                xAxisGroup.transition(transition)
                    .call(xAxis);
                yAxisGroup.transition(transition)
                    .call(yAxis);

                d3.selectAll(".tick text").attr('font-size', '10pt');
            }
            //while (1) {
            for (const date in dateList) {
                updateBarChart(date);
                await new Promise(done => setTimeout(() => done(), interval));
            }
            //}
        }

        async function renderMap() {
            const paletteScale = d3.scaleLinear()
                .domain([minValue, maxValue])
                .range(['#EFEFFF', '#CF4646']);

            var selectedLayer = worldMapSvg.append('g').attr('class', 'selected-countries');
            var layer = worldMapSvg.append('g').attr('class', 'countries');
            const projection = d3.geoMercator()
                .fitSize([width, height], geo)
                .scale(150)
            // .translate([width, height]);
            // console.log(projection([116.418757, 39.917544]));
            const path = d3.geoPath().projection(projection);

            // zooming
            const zoomed = ({ transform }) => {
                layer.attr('transform', transform);
                selectedLayer.attr('transform', transform);
            };
            worldMapSvg.call(d3.zoom().scaleExtent([0.5, 40]).on('zoom', zoomed));
            // draw world map
            layer.selectAll('path')
                .data(geoData, (d) => d.id)
                .join(
                    enter => {
                        enter
                            .append('path')
                            .attr('class', (d) => `country ${d.id}`)
                            .attr('d', path)
                            .style('fill', (d) => d.properties.fillColor)
                            .style('stroke', 'none');
                    },
                    () => { },
                    exit => {
                        exit
                            .remove();
                    },
                );
            // draw boundaries
            layer.selectAll('.country-boundary')
                .data([boundaries])
                .join(
                    enter => {
                        enter
                            .append('path')
                            .attr('d', path)
                            .attr('class', 'country-boundary')
                            .style('stroke', 'black')
                            .style('stroke-width', 1)
                            .style('stroke-opacity', 0.3)
                            .style('fill', 'none');
                    },
                    () => { },
                    exit => {
                        exit.remove()
                    }
                );
        }
        const render = async function () {
            await dataLoadandSetup();

            renderBarRacing(monthData);
            renderMap();

        }
        render();
    </script>
</body>